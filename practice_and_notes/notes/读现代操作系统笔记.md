# 现代操作系统(第三版)笔记
## 索引
[部分概念及硬件知识](#部分概念及硬件知识)  
[操作系统相关知识](#操作系统相关知识)

## 部分概念及硬件知识
* 图形用户界面(GUI)实际上不是操作系统的一部分
* 计算机的运行状态分为内核态(管态, 核心态), 用户态

### CPU
* 每个处理器都有一套专门的指令集, 根据不同指令集开发的程序, 无法在非对应的CPU上运行
* 通用寄存器: 用于存放变量和临时结果
* 程序计数器: 保存将要取出的下一条指令的内存地址, 当命令取出之后就会更新为指向后继指令的内存地址
* 堆栈指针: 指向内存中当前栈的顶端
* 程序状态字寄存器(PSW): - TODO
* 在时间多路复用(time multiplexing)CPU中, 操作系统经常会中止某些正在运行的程序并启动另外一个程序, 每次停止运行一个程序时, 操作系统就必须保存所有的寄存器, 稍后这个程序再被启动时, 就可以将寄存器重新装入

* 流水线(pipeline): 当一条指令被取入流水线当中, 它就必须被执行完毕
* 流水线造成了机器实现软件的复杂性问题
* 超标量CPU: 有多个执行单元, 可以使程序不需要按顺序执行
* TRAP: 可以将用户态切换到内核态
* 多线程, 多核芯片 - TODO

### 存储器
* 存储器系统中的顶层是寄存器, 可以有软件决定如何使用
* 存储器系统第二层是高速缓存, 多数由硬件控制
* 主存被分割为高速缓存行(cache line), CPU所需高速缓存行是否在高速缓存中, 如果在则命中, 无需访问内存, 否则访问内存

## 操作系统相关知识
### 进程
* 进程本质上就是正在执行的一个程序, 基本是容纳运行一个程序所需的所有信息的容器
* 与每个进程相关的是进程的地址空间
* 进程树 - TODO
* 系统管理器授权每个进程使用一个给定的UID(User IDentification)标识
* 每个被启动的进程都有一个启动该进程的用户UID
* 子进程拥有与父进程一样的UID
* 用户可能是某个组的成员, 每个组也有一个GID(Group IDentification)标识

### 地址空间
* 从某个最小值存储位置到最大值存储位置的列表, 在地址空间中进程可以进出读写, 地址空间中存放有可执行程序, 程序的数据以及程序的堆栈...

### 文件
* 大多数操作系统支持目录(directory)的概念, 从而可以将文件分类为组
* 目录层结构中的每一个文件都可以通过从目录顶部, 即根目录(root directory)开始的路径名(path name)来确定

### 输入/输出
### 保护
### shell
* shell 不是操作系统的组成部分

## 一些实例
### POSIX

#### 进程管理

|调用|说明|
|---|---|
|`pid = fork()`|创建与父进程相同的子进程|
|`pid = waitpid(pid, &statloc, options)`|等待一个子进程终止|
|`s = execve(name, argv, environp)`|替代一个子进程的核型映像|
|`exit(status)`|终止进程执行并返回状态|

#### 文件管理

|调用|说明|
|---|---|
|`fd = open(file, how, ...)`|打开一个文件供读, 写或两者|
|`s = close(fd)`|关闭一个打开的文件|
|`n = read(fd, buffer, nbytes)`|把数据从一个文件读到缓冲区中|
|`n = write(fd, buffer, nbytes)`|把数据从缓冲区写到一个文件中|
|`position = lseek(fd, offset, whence)`|移动文件指针|
|`s = stat(name, &buf)`|获取文件状态信息|

#### 目录和文件系统管理

|调用|说明|
|---|---|
|`s = mkdir(name, mode)`|创建一个新目录|
|`s = rmdir(name)`|删去一个空目录|
|`s = link(name1, name2)`|创建一个新目录项name2, 并指向name1|
|`s = unlink(name)`|删去一个目录项|
|`s = mount(special, name, flag)`|安装一个文件系统|
|`s = umount(special)`|卸载一个文件系统|

#### 杂项

|调用|说明|
|---|---|
|`s = chdir(dir name)`|改变工作目录|
|`s = chmod(name, mode)`|修改一个文件的保护位|
|`s = kill(pid, signal)`|发送信号给一个进程|
|`seconds = time(&seconds)`|自1970年1月1日起的流逝时间(时间戳)|


### read系统
#### 一些需要记住的事情
* 单核且单CPU计算机 一次只能执行一条指令
> 一个进程正在用户态中运行一个用户进程, 并且需要一个系统服务, 比如文件读取那么它就必须执行一个TRAP或者系统调用指令, 将控制转移到操作系统. 操作系统接着通过参数检查找出所需要调用进程, 然后执行系统调用, 并把控制返回给在系统调用后面更随着的指令, 某种意义上系统调用像是在进行一次特殊的过程调用,但是系统调用可以进入内核, 而过程调用则不能

