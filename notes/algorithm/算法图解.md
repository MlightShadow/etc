# 算法图解

## 二分查找

仅当列表为有序的时候, 二分查找才有用.

## 大O表示法

常见的5种
O(log n) 对数时间
O(n) 线性时间
O(n * log n)
O(n^2)
O(n!)

算法的速度讨论的并非时间, 而操作数的增速

## 数组和链表

|      | 数组 | 链表 |
| ---- | ---- | ---- |
| 插入 | O(n) | O(1) |
| 读取 | O(1) | O(n) |
| 插入 | O(n) | O(1) |

## 选择排序

O(n^2)
速度较慢, 通过2次循环遍历完成排序

## 递归与调用栈

使用递归时调用栈需要消耗大量内存, 解决办法: 1.使用循环;2.使用尾递归(但不是所有语言都支持尾递归);

## D&C(分而治之)

* 找出简单的基线条件
* 确定如何缩小问题的规模, 使其符合基线条件

## 快速排序

通过从空数组与一个元素的数组直接返回, 作为基线条件
将更多元素的数组通过基准值分为两个子数组, 从而不断进行排序

## 散列表
